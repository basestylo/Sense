defmodule Tortoise.Handler.SenseMQTT do
  use Tortoise.Handler
  alias Sense.{Repo, User, Device, Metric, Measure}

  def init(args) do
    {:ok, args}
  end

  def connection(status, state) do
    # `status` will be either `:up` or `:down`; you can use this to
    # inform the rest of your system if the connection is currently
    # open or closed; tortoise should be busy reconnecting if you get
    # a `:down`
    {:ok, state}
  end

  #  topic filter room/+/temp
  def handle_message([username, device_name, metric_name], payload, state) do
    user = Repo.get_by!(User, username: username)

    {:ok, device} =
      case Repo.get_by(Device, user_id: user.id, name: device_name) do
        nil  -> %Device{name: device_name, description: "Autogenerated", user_id: user.id} # not found, we build one
        device -> device                   # exists, let's use it
      end
      |> Device.changeset
      |> Repo.insert_or_update

    {:ok, metric} =
      case Repo.get_by(Metric, device_id: device.id, name: metric_name) do
        nil  -> %Metric{name: metric_name, description: "Autogenerated", device_id: device.id} # not found, we build one
        metric -> metric                   # exists, let's use it
      end
      |> Metric.changeset
      |> Repo.insert_or_update

    Measure.write_measure(metric, Float.parse(payload) |> Tuple.to_list |> List.first)

    IO.puts "[Tortoise.Handler.SenseMQTT] held message: #{Enum.join([username, device_name, metric_name], "-")}/#{payload}/#{state}"

    {:ok, state}
  end

  def handle_message(topic, payload, state) do
    # unhandled message! You will crash if you subscribe to something
    # and you don't have a 'catch all' matcher; crashing on unexpected
    # messages could be a strategy though.

    IO.puts "[Tortoise.Handler.SenseMQTT] Unheld message: #{Enum.join(topic, "-")}/#{payload}/#{state}"
    IO.inspect topic

    {:ok, state}
  end

  def subscription(status, topic_filter, state) do
    {:ok, state}
  end

  def terminate(reason, state) do
    # tortoise doesn't care about what you return from terminate/2,
    # that is in alignment with other behaviours that implement a
    # terminate-callback
    :ok
  end
end
